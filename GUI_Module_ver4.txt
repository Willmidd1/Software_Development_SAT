'''
SOFTWARE DEVELOPMENT PROJECT
Client Update Utility - GUI MODULE

Made By: Will 12SDA
Started on 15/07/2020

This code contains the code required for all pages of
the GUI and its functionality. This file does most of the
work and can be considered the main file of this project.

Naming Conventions: Camel Case

This uses:
Data_Management_Module.py
Automatic_Updates_Module.py
Update_Log_Manager_Module.py

External/imported libraries used:
tkcalendar library (in libraries folder)
pytz library (in libraries folder)
babel library (in libraries folder)

'''

#Import dependencies
from tkinter import *
from tkinter import ttk
import tkinter as tk
from tkinter import simpledialog
from tkinter import messagebox
from tkinter.filedialog import askopenfilename
from tkinter.filedialog import askdirectory
import os
import threading
import shutil
from datetime import datetime  

#Modules I created
import Data_Management_Module as data_manager
import Automatic_Updates_Module as automation_module
import Update_Log_Manager_Module as update_log

#-----------------------------------------------------------------------------------------------

#Variables to keep track of the windows position on the screen
winX = 100
winY = 100

#Define other required global variables. These need to be stored globally in order to be preserved across GUI pages
tickbox_Y = 0
btnList = []
clientList = [] #Create a list where clients will be added
mainFrame = 0
isFirstLoad = True
switchStatus = False
pauseStatus = False
emailReminders = False
activeClients = []
arrDatePanels = []
arrEventPanels = []
dayLabels = []
eventInformation = []
logLines = []
selectedMonth = 7
filenameTXT,strLastUpload,uploadedFile,popupMenu,strTimestamp,strPauseStatus,strUpdateStatus = "","","","","","",""
updateFrequency, updateFrequencyTXT  = "Update Frequency: 24:00:00", ""
nextUpdate,nextUpdateText = "Next Update: 27/07 14:00",""
updateButton = ""
updateLogList = ""


#Function to clear a GUI page
def clearPage(window):
    global winX, winY
    winX = window.winfo_x() #Save the x and y position of the window
    winY = window.winfo_y()
    window.destroy()


#Function to setup basic root window
def setupWindow(window):
    #Configure Root Window and preserve its previous position
    window.geometry("800x670+"+str(winX)+"+"+str(winY)) #Width x Height + PosX + PosY
    window.configure(bg = "#333333")
    window.title("v1.0") #Display software version number
    window.wm_iconbitmap('images/icon.ico') #Add software icon
    window.resizable(width=False, height=False) #Stop user from being able to resize the window


#Function to clear a txt file
def deleteContent(pfile):
    pfile.seek(0)
    pfile.truncate()
    
#-----------------------------------------------------------------------------------------------
    
#Create a client class for each row of the client list
class client():
    def __init__(self, name, url, version,active):
        self.name = name
        self.url = url
        self.version = version
        self.active = active
        self.info = ""

    #Draws client to the GUI
    def drawClient(self):
        global tickbox_Y, mainFrame
        
        self.nameLabel = Label(mainFrame, text=str(self.name), bg="#1a1a1a",fg="White",font=("{Lucida Console}",10))
        self.nameLabel.place(x=65,y=tickbox_Y+5)

        self.urlLabel = Label(mainFrame, text=str(self.url), bg="#1a1a1a",fg="White",font=("{Lucida Console}",9))
        self.urlLabel.place(x=240,y=tickbox_Y+6)

        self.versionLabel = Label(mainFrame, text=str(self.version), bg="#1a1a1a",fg="White",font=("{Lucida Console}",10))
        self.versionLabel.place(x=505,y=tickbox_Y+5)
        
    #Delete GUI elements
    def destroyClient(self):
        self.nameLabel.destroy()
        self.urlLabel.destroy()
        self.versionLabel.destroy()

    def updateState(self):
        #Save this new state to the text file by finding its id
        clientTXT = open("data/client-list.txt","r+")
        lines = clientTXT.readlines()
        deleteContent(clientTXT)
        for line in lines:
            if line != "\n":
                if int(line[0:1]) == int(self.name[0:1]):
                    i = lines.index(line)
                    line = self.name + "," + self.url + "," + self.version + "," + str(self.active) + "\n"
                    lines[i] = line
        clientTXT.writelines(lines)
        clientTXT.close()


#-----------------------------------------------------------------------------------------------

#Function to check if a new event being added is on a date where there is no current event
def checkExistingEvents(item):
    global arrEventPanels

    for event in arrEventPanels:
        if event[0] == item.day and event[1] == item.month:
            return True
            break
    else:
        return False

#-----------------------------------------------------------------------------------------------

#FUNCTIONS TO BE ACCESSED BY OTHER MODULES:

#Change the GUI of the moost recent update call
def setMostRecentUpdateText():
    global strTimestamp, strUpdateStatus, nextUpdateText
    
    currentDate = datetime.now()
    
    #Format date
    m = str(currentDate.month)
    d = str(currentDate.day)
    h = str(currentDate.hour)
    mi = str(currentDate.minute)
    y = str(currentDate.year)

    #Add zeroes in front of values less than ten so it appears nice on the GUI
    if int(m) < 10:
        m = "0" + m
    if int(d) < 10:
        d = "0" + d
    if int(h) < 10:
        h = "0" + h
    if int(mi) < 10:
        mi = "0" + mi

    #Format it appropriately
    outputTime = d + "/" + m + "/" + y + " " + h + ":" + mi

    strUpdateStatus.set("Success")
    strTimestamp.set(outputTime)

    if switchStatus:
        nextUpdate = "Next Update: " + automation_module.calculateNextUpdate()
        nextUpdateText.set(nextUpdate)


#Short function to draw the lines into the update log's gui
def drawUpdateLog(log, boolUpdateLogLines):
    global updateLogList, logLines

    if boolUpdateLogLines:
        logLines = log

    try:
        updateLogList.delete(0,END) 

        for line in log:
            updateLogList.insert(END, line)
    except:
        #The page isnt loaded and thus it cannot draw the log
        print("Page not loaded.")
    
#-----------------------------------------------------------------------------------------------

        
#A function is used to set up each GUI page so that buttons can cycle between pages. This is page 1, the main page
def Setup_GUI_Page1():
    global strPauseStatus, filenameTXT, strLastUpload, switchStatus, updateFrequency, updateFrequencyTXT, nextUpdate, nextUpdateText, strTimestamp,strUpdateStatus, updateLogList, uploadedFile, logLines
    
    uploadedFile = ""

    root = Tk()

    setupWindow(root) #Draw basic window


    #Configure Static Text Labels
    title = Label(root, text="Client Update Utility",bg="#333333",fg="White",font=("Helvetica", 18, 'bold'))
    title.place(x=450,y=30)

    statusLabel = Label(root, text="Most Recent Update:",bg="#333333",fg="White",font=("Helvetica", 12))
    statusLabel.place(x=490, y=100)

    timeLabel = Label(root, text="Last Updated:",bg="#333333",fg="White",font=("Helvetica", 12))
    timeLabel.place(x=490, y=140)

    uploadDataTitle = Label(root, text="Upload New Update Data:",bg="#333333",fg="White",font=("Helvetica", 13, 'bold'))
    uploadDataTitle.place(x=370,y=440)

    autoUpdatesLabel = Label(root, text="Automatically Update Clients:",bg="#333333",fg="#999999",font=("Helvetica", 11))
    autoUpdatesLabel.place(x=395,y=610)

    logFilterLabel = Label(root, text="Filter Log By:",bg="#333333",fg="White",font=("Helvetica", 12, 'bold'))
    logFilterLabel.place(x=10, y=550)

    logExportLabel = Label(root, text="Export Update Log:",bg="#333333",fg="White",font=("Helvetica", 12, 'bold'))
    logExportLabel.place(x=10, y=610)



    #Configure Variable or code-accessible strings
    strUpdateStatus = tk.StringVar()
    strUpdateStatus.set("       -")
    statusContent = Label(root, textvariable=strUpdateStatus,bg="#333333",fg="#00ff00",font=("Helvetica", 12, 'bold'))
    statusContent.place(x=643, y=100)

    strTimestamp = tk.StringVar()
    strTimestamp.set("No recent update")
    timestamp = Label(root, textvariable=strTimestamp,bg="#333333",fg="#5e99ff",font=("Helvetica", 12))
    timestamp.place(x=601, y=140)

    strLastUpload = tk.StringVar()
    strLastUpload.set("   Last upload: Never")
    lastUploadLabel = Label(root, textvariable=strLastUpload,bg="#333333",fg="#999999",font=("Helvetica", 10))
    lastUploadLabel.place(x=480,y=550)

    strPauseStatus = tk.StringVar()
    strPauseStatus.set("Running...")
    PauseButtonLabel = Label(root, textvariable=strPauseStatus,bg="#333333",fg="#999999",font=("Helvetica", 10))
    PauseButtonLabel.place(x=385,y=180)

    outline = Frame(bg='#333333',highlightbackground="#666666", highlightcolor="#666666", highlightthickness=1,bd=0,width=100,height=24)
    outline.place(x=483,y=486)
    filenameTXT = tk.StringVar()
    filenameTXT.set("No File Selected.")
    fileStatus = Label(outline,textvariable=filenameTXT, bg="#333333",anchor='w',font=("Helvetica", 10),width=16)
    fileStatus.pack()

    nextUpdateText = tk.StringVar()
    if switchStatus:
        nextUpdateText.set(nextUpdate)
    else:
        nextUpdateText.set("")
    nextUpdateLabel = Label(root, textvariable=nextUpdateText,bg="#333333",fg="#999999",font=("Helvetica", 11))
    nextUpdateLabel.place(x=526, y=178)

    updateFrequencyTXT = tk.StringVar()
    autoUpdatesLabel = Label(root, textvariable=updateFrequencyTXT,bg="#333333",fg="#999999",font=("Helvetica", 9))
    autoUpdatesLabel.place(x=532,y=210)
    if switchStatus:
        updateFrequencyTXT.set(updateFrequency)
    else:
        updateFrequencyTXT.set("")


    
    #Configure updatte log and scrollbar functionality
    logCanvas = Canvas(root,width=350,height=500) #Canvas for output log
    logCanvas.place(x=10,y=10)

    scrollbar = Scrollbar(logCanvas) #Create Scrollbar widget


    #Set listbox widget for scrolling
    updateLogList = Listbox(logCanvas,yscrollcommand=scrollbar.set,width=45,height=30,font=("{Lucida Console}",10),bg="#1a1a1a",fg="White",bd=0,highlightthickness=0, relief='ridge')
    if len(logLines) != 0:
        drawUpdateLog(logLines, False)
        setMostRecentUpdateText()
    else:
        updateLogList.insert(END,"")
        updateLogList.insert(END, "UPDATE LOG") #Enter first line in log

    updateLogList.pack(side=LEFT,fill=BOTH)
    scrollbar.pack(side=RIGHT,fill=Y)
    scrollbar.config(command=updateLogList.yview,bg="black",activebackground="#313131")



    #Create horizontal divider line
    line = Frame(root,height=2,width=400,bg='#666666')
    line.place(x=370,y=410)



    #Configure File Uploading
    def browseFiles():
        global filenameTXT, uploadedFile
        
        print("Browsing files...")  
        filename = askopenfilename() #show an "Open" dialog box and return the path to the selected file

        if data_manager.validateFileType(filename) == True: #Call a function I wrote in another module to validate this file. See 'Data_Management_Module.py'
            filenameTXT.set(os.path.basename(filename)) #Set the GUI to display the name of the file
            uploadedFile = filename #Set the global variable so the uploadFiles() function can use it
        else:
            messagebox.showwarning(title="Warning", message="Invalid file type. You may only upload .txt or .csv upload data.")


    def uploadFiles():
        global uploadedFile, strLastUpload
    
        print("Files uploading...")
        if uploadedFile != "": #if there  is something uploaded
            data_manager.moveToRepository(uploadedFile) #Call a function from 'Data_Management_Module.py' to add this file to the repository
            messagebox.showinfo(title="Success", message="File uploaded successfully. It will be distributed in the next update.") 
            currentTime = datetime.now()
            if currentTime.minute < 10:
                currentMin = "0" + currentTime.minute
            else:
                currentMin = currentTime.minute
            lastUpload = "Last Upload: " + str(currentTime.day) + "/" + str(currentTime.month) + " " + str(currentTime.hour) + ":" + str(currentMin)
            strLastUpload.set(lastUpload)
        else:
            messagebox.showwarning(title="Warning", message="There is no file uploaded. Please select browse.")
        


    #Setup browse and upload files buttton
    browseButtton = Button(root, width=9,height=1,text="Browse...",bg="#7d7d7d",activebackground='#575656', command=browseFiles)
    browseButtton.place(x=410,y=485)

    uploadButtton = Button(root, width=9,height=1,text="Upload",command=uploadFiles)
    uploadButtton.place(x=620,y=485)


    #Automatic Uploads Switch
    if not switchStatus:
        img = PhotoImage(file="images/toggle_switch_off.png")
    else:
        img = PhotoImage(file="images/toggle_switch_on.png")

    def autoUpdatesToggle():
        global switchStatus, pauseStatus, clientList, updateFrequencyTXT, updateFrequency, nextUpdate, nextUpdateText, updateButton
        
        if not switchStatus:
            if len(clientList) > 0:
                img.config(file="images/toggle_switch_on.png")
                switchStatus = True
                
                automation_module.isPaused = pauseStatus #Have the updates pause or unpause depending on the state of the pause button GUI
                
                #Input frequency of automatic updates
                frequency = simpledialog.askstring("Please Input", "Input frequency of automatic updates (in the format: hh:mm:ss).\nRecommended 24 hours (24:00:00).")
                validated = False


                
                #
                # VALIDATE INPUTTED FREQUENCY - Inputted when you turn on the automatic updates switch
                #
                
                while not validated: #Keep getting input until it is validated
                    
                    if frequency != "" and frequency != None: #Perform existace check
                        if len(frequency.split(":")) == 3: #Perform a format check to ensure it is in the format hh:mm:ss
                            
                            try: #Perform a type check, as if the code below cannot convert the inputs to integers it will run the code in 'except'
    
                                if int(frequency.split(":")[0]) < 90: #Dont allow more than 90 hours of update frequency. Range check
                                    if int(frequency.split(":")[1]) < 60 and int(frequency.split(":")[2]) < 60: #Perform range check on minutes and seconds
                                        validated = True #It has passed the checks, it is validated
                                    else:
                                        #Ask for inputs again - was not in correct range
                                        frequency = simpledialog.askstring("Please Input", "MINUTES OR SECONDS CANNOT BE MORE THAN 60\nInput frequency of automatic updates (in the format: hh:mm:ss).")
                                else:
                                    #Ask for them to input again - was not in correct range
                                    frequency = simpledialog.askstring("Please Input", "MUST NOT BE MORE THAN 90 HOURS\nInput frequency of automatic updates (in the format: hh:mm:ss).")

                            except:
                                #Ask for them to input again - not correct data type
                                frequency = simpledialog.askstring("Please Input", "MUST BE INTEGERS\nInput frequency of automatic updates (in the format: hh:mm:ss).")
                        else:
                            #Ask for them to input again - was not in correct format
                            frequency = simpledialog.askstring("Please Input", "NOT IN CORRECT FORMAT\nInput frequency of automatic updates (in the format: hh:mm:ss).")

                    else:
                        #Ask for them to input again - the input was blank
                        frequency = simpledialog.askstring("Please Input", "MUST NOT BE BLANK\nInput frequency of automatic updates (in the format: hh:mm:ss).")

                #
                # End of validation
                #


                messagebox.showinfo(title="Success", message="Automatic updates are now on. The 'Next Update' text \nwill show when the next auto update will be")
                automation_module.updateFrequency = frequency

                #Run the while loop in the automation module in a thread so that it can run independantly of this file and thus not halt this file from continuing
                th = threading.Thread(target=automation_module.runUpdateLoop, args=(clientList , ))
                th.start()
                    
                #Change some GUI elements
                updateFrequency = "Update Frequency: " + frequency
                updateFrequencyTXT.set(updateFrequency)
                nextUpdateText.set(nextUpdate)
                updateButton.place_forget()
                nextUpdate = "Next Update: " + automation_module.calculateNextUpdate()
                nextUpdateText.set(nextUpdate)
            else:
                messagebox.showwarning(title="Warning", message="You cannot turn on automatic updates as there are \nno clients in the list to update to.")
        else:
            img.config(file="images/toggle_switch_off.png")
            switchStatus = False
            
            #Change some GUI elements
            updateFrequencyTXT.set("")
            nextUpdateText.set("")
            updateButton.place(x=563,y=178)
            
            #Stop the automatic updates
            automation_module.isPaused = True #Using the module I created, stop the automatic updates

    switch = Button(root, image=img, bd=0,highlightthickness=0, relief='ridge', command=autoUpdatesToggle)
    switch.place(x=600,y=610)


    #Save a txt file of the update log to the user's computer 
    def saveFile(fileType):
        directory = askdirectory(title="Save " + fileType + " Update Log")

        if fileType == "TXT" and directory != "": #TXT exporting
            file = open("data/update-log-txt.txt","r+") #open the txt file
            deleteContent(file) #clear the file
            file.write('\n'.join(update_log.arrUpdateLogLines) + '\n') #Write the txt with the update log
            file.close()

            #Get filename from user
            fileName = simpledialog.askstring("Please Input", "What do you want to name the file? \n(If blank, name will be update-log-txt)")

            #
            # VALIDATE ENTERED FILE NAME - When exporting the update log
            #

            
            if fileName == "" or fileName == None: #Existence check to see if they have entered anything
                fileName = "update-log-txt" #If not, use a deafult name
            
            shutil.copy("data/update-log-txt.txt", directory) #Copy the file to their desired folder


            #Validate file name, make sure it does not include windows restricted characters, if it does it will return OSError and run the except
            try:
                os.rename(directory + "/update-log-txt.txt",directory + "/" + fileName + ".txt") #rename the file
                
            except OSError:
                #It had invalid characters, therefore use a deafult name
                fileName = "update-log-txt"
                messagebox.showwarning(title="Warning", message="Invalid characters in filename, deafult name (update-log-csv) was used")
            
            messagebox.showinfo(title="Success", message=fileName + ".txt saved to " + directory.split("/")[len(directory.split("/"))-1] + " successfully.")

            #
            # END OF VALIDATION
            #
            
        elif fileType == "CSV" and directory != "": #CSV exporting
            file = open("data/update-log-csv.csv","r+") #open the txt file
            deleteContent(file) #clear the file
            file.write('\n'.join(update_log.formatCSV()) + '\n') #Format the csv file using update log manager module. It should open and work well in ms excel
            file.close()

            #
            # VALIDATE FILE NAME - Same as validation above but for .csv
            #
                    
            fileName = simpledialog.askstring("Please Input", "What do you want to name the file? \n(If blank, name will be update-log-csv)")

            if fileName == "" or fileName == None: #Existence check to see if they have entered anything
                fileName = "update-log-csv" #If not, use a deafult name

            shutil.copy("data/update-log-csv.csv", directory) #Copy the file to their desired folder

            #Validate file name, make sure it does not include windows restricted characters, if it does it will return OSError and run the except
            try:
                os.rename(directory + "/update-log-csv.csv",directory + "/" + fileName + ".csv") #rename the file
                
            except OSError: #This is validation to check that the inputted file name doesnt violate the restricted filename characters in windows
                #It had invalid characters, therefore use a deafult name
                fileName = "update-log-csv"
                messagebox.showwarning(title="Warning", message="Invalid characters in filename, deafult name (update-log-csv) was used")

            messagebox.showinfo(title="Success", message=fileName + ".csv saved to " + directory.split("/")[len(directory.split("/"))-1] + " successfully.")

            #
            # END OF VALIDATION
            #

    #Export and Filter Buttons
    exportTXTButton = Button(root,width=5, text=".txt", bg="#333333",fg="#999999",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1,command=lambda: saveFile("TXT"))
    exportTXTButton.place(x=180,y=607)

    exportCSVButton = Button(root,width=5, text=".csv", bg="#333333",fg="#999999",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1,command=lambda: saveFile("CSV"))
    exportCSVButton.place(x=250,y=607)

    filterName = Button(root,text="Client Name",activebackground='#333333',bg="#333333",fg="#999999",font=("Helvetica", 10),bd=0,highlightthickness=0, relief='ridge',command=update_log.filterName)
    filterName.place(x=125,y=550)

    filterDate = Button(root,text="Date",activebackground='#333333',bg="#333333",fg="#999999",font=("Helvetica", 10),bd=0,highlightthickness=0, relief='ridge',command=update_log.filterDate)
    filterDate.place(x=225,y=550)

    filterStatus = Button(root,text="Fail -\nSuccess",activebackground='#333333',bg="#333333",fg="#999999",font=("Helvetica", 10),bd=0,highlightthickness=0, relief='ridge',command=update_log.filterStatus)
    filterStatus.place(x=283,y=545)

    vLine = Frame(root,height=40,width=2,bg='#666666')
    vLine.place(x=210,y=543)

    vLine2 = Frame(root,height=40,width=2,bg='#666666')
    vLine2.place(x=270,y=543)



    #Pause button functionality
    global pauseStatus
    if not pauseStatus:
        img2 = PhotoImage(file="images/pause_button_unpaused.png")
        strPauseStatus.set("Running...")
    else:
        img2 = PhotoImage(file="images/pause_button_paused.png")
        strPauseStatus.set(" Paused")

    def pauseUpdates():
        global strPauseStatus, pauseStatus, clientList

        if not pauseStatus:
            img2.config(file='images/pause_button_paused.png')
            pauseStatus = True
            strPauseStatus.set(" Paused")
            automation_module.isPaused = True
            if switchStatus:
                messagebox.showinfo(title="Paused", message="Automatic updates are now paused")
            else:
                messagebox.showinfo(title="Paused", message="Automatic updates are paused, but they are not running. Please press the toggle switch to activate them if you wish.")
        else:
            img2.config(file='images/pause_button_unpaused.png')
            pauseStatus = False
            strPauseStatus.set("Running...")
            automation_module.isPaused = False
            if switchStatus:
                messagebox.showinfo(title="Paused", message="Automatic updates have been resumed")
            else:
                messagebox.showinfo(title="Paused", message="Automatic updates are un-paused, but they are not running. Please press the toggle switch to activate them if you wish.")

            #Run the while loop in the automation module in a thread so that it can run independantly of this file and thus not halt this file from continuing
            th = threading.Thread(target=automation_module.runUpdateLoop, args=(clientList , ))
            th.start()
            
        
    pauseButton = Button(root, image=img2,bd=0,highlightthickness=0, relief='flat',command=pauseUpdates)
    pauseButton.place(x=380, y=103)

    #Functions to handle the opeening of different GUI Pages
    def openWebsiteList():
        clearPage(root) #Clear the page
        Setup_GUI_Page2() #Draw the desired page

    def openUpdateScheduler():
        clearPage(root)
        Setup_GUI_Page3()

        
    #PNG Open scheduler and client website list buttons
    img3 = PhotoImage(file='images/scheduler_button.png')
    updateScheduler = Button(root, image=img3,bd=0,highlightthickness=0, relief='flat', command=openUpdateScheduler)
    updateScheduler.place(x=465,y=260)

    img4 = PhotoImage(file='images/website_list_button.png')
    websiteListtButton = Button(root, image=img4,bd=0,highlightthickness=0, relief='flat', command=openWebsiteList)
    websiteListtButton.place(x=446,y=330)

    #Added a new button which was not in the design. This rolls out an update on click of the button
    def runUpdate():
        global clientList, uploadedFile
    
        if uploadedFile != "": #if there  is something uploaded
            if len(clientList) > 0:
                automation_module.version += 0.1
            
                versionTXT = open("data/current-update-version.txt","r+") #Open up the text file to save version
                versionTXT.write(str(automation_module.version)[0:3]) #Save the version
                versionTXT.close()
            
                data_manager.distributeUpdates(clientList, str(automation_module.version)[0:3]) #Using 'Data_Management_Module.py', distribute an update to each client
                messagebox.showinfo(title="Success", message="Update distributed to all active clients.")
                setMostRecentUpdateText()
                update_log.addToUpdateLog(clientList, str(automation_module.version)[0:3]) #Add to the log
            else:
                messagebox.showwarning(title="Warning", message="There are no clients in the list to update to.")
        else:
            messagebox.showwarning(title="Warning", message="There is no file uploaded. Please select browse.")

    global updateButton
    updateButton = Button(root, width=12,height=1,text="Run an Update",bg="#7d7d7d",activebackground='#575656',command=runUpdate)
    updateButton.place(x=563,y=178)
    
    if switchStatus:
        updateButton.place_forget()


    root.mainloop() #Begin main GUI Loop

    # END OF PAGE ONE SETUP #


#-----------------------------------------------------------------------------------------------


#Function used by pages 2 and 3 to open the home page of the program
def openHomePage(root):
    clearPage(root) #Clear the page
    Setup_GUI_Page1() #Draw the desired page


#-----------------------------------------------------------------------------------------------


#Function to setup GUI for page 2, the website list page
def Setup_GUI_Page2():
    global tickbox_Y, clientList, mainFrame, isFirstLoad
    
    root = Tk()

    tickbox_Y = 65 #Reset a global variable

    setupWindow(root) #Draw basic window

    #Configure main Frame element
    mainFrame = Frame(root,width=640,height=500,bg="#1a1a1a",bd=0,highlightthickness=0, relief='ridge')
    mainFrame.place(x=20, y=70)

    
    #Configure Static Text Labels
    title = Label(root, text="Client Website List",bg="#333333",fg="White",font=("Helvetica", 18, 'bold'))
    title.place(x=20,y=20)

    nameTitle = Label(mainFrame, text="CLIENT NAME",bg="#1a1a1a",fg="White",font=("{Lucida Console}",10,'bold'))
    nameTitle.place(x=65,y=30)

    urlTitle = Label(mainFrame, text="WEBSITE LINK",bg="#1a1a1a",fg="White",font=("{Lucida Console}",10,'bold'))
    urlTitle.place(x=260,y=30)

    versionTitle = Label(mainFrame, text="CURRENT VERSION",bg="#1a1a1a",fg="White",font=("{Lucida Console}",10,'bold'))
    versionTitle.place(x=460,y=30)



    #Client List Functionality Setup
    
    #Create a tickbox class which can be applied to multiple boxes
    class tickBox():
        def __init__(self,X,Y,ticked): #Takes x,y arguments for its position on screen
            self.ticked = ticked
            if self.ticked:
                self.image = "images/checkbox_checked.png"
            else:
                self.image = "images/checkbox_unchecked.png"
            self.boundClient = -1
    
            self.img = PhotoImage(file=self.image)
            self.btn = Button(mainFrame, image=self.img,bd=0,highlightthickness=0, command=self.changeState)
            self.btn.place(x=X,y=Y)

        #Method called when tick button is clicked
        def changeState(self):
            if not self.ticked:
                self.ticked = True
                self.image = "images/checkbox_checked.png"
            else:
                self.ticked = False
                self.image = "images/checkbox_unchecked.png"
        
            self.img.config(file=self.image) #Change image to match button's state
            clientList[self.boundClient].active = self.ticked #Change state of bound client
            clientList[self.boundClient].updateState()

        #Method to remove button
        def remove(self):
            try:
                self.btn.destroy()
            except:
                pass

                    
    #Test when page reloads if clients need to be redrawn
    if len(clientList) > 0:
        #Loop through all remaining clients and draw them one by one
        for i in range(0,len(clientList)):
            clientList[i].name = str(i+1) + ". " + clientList[i].name[3:len(clientList[i].name)] #Have the name with the right number or id out the front
            clientList[i].drawClient()
            box = tickBox(15,tickbox_Y,clientList[i].active)
            btnList.append(box)
            tickbox_Y += 65
            box.boundClient = i #Bind this checkbox with this client


 
    #Function to create and add a new client object 
    def addClient(isInputRequired, n, u, v):
        global tickbox_Y, clientList

        if len(clientList) < 6:
            if isInputRequired:
                inputtedName = simpledialog.askstring("Please Input", "Input Name for new client:")
                validated = False

                #
                # VALIDATE CLIENT NAME INPUT - This is called when you add a new client and enter its name
                #

                #An array of restriced windows filename characters, a client cannot have these names as files have to be created for each client
                restrictedCharacters = ["<",">",":",'"',"/","\\","|","?","*","con","prn","aux","nul","com1","com2","com3","com4","com5","com6","com7","com8","com9","com0","lpt1","lpt2","lpt3","lpt4","lpt5","lpt6","lpt7","lpt8","lpt9","lpt0"]

                while not validated: #keep looping until it is validated
                    if inputtedName != "" and inputtedName != None: #Perform an existance check to see if they left it blank

                        #Loop through the restricted characters to see if they have entered ant windows-restricted file names
                        for char in restrictedCharacters:
                            if char in inputtedName.lower(): #Check if the invalid character  is in what they inputted
                                #Get them to input again
                                inputtedName = simpledialog.askstring("Please Input", "INVALID CHARACTERS IN CLIENT NAME\nInput Name for new client:")
                                break
                        else: #Else on a for loop, checks whether break was called in the loop. If not it runs else
                            
                            #Loop through already existing clients to check if the name is taken
                            for existingClient in clientList:
                                if existingClient.name[3:len(existingClient.name)] == inputtedName: #Check the inputted name against the client's name
                                    #Get them to input again
                                    inputtedName = simpledialog.askstring("Please Input", "CLIENT NAME ALREADY EXISTS\nInput Name for new client:")
                                    break
                            else:
                                #Else on a for loop, checks whether break was called in the loop. If not it runs else
                                validated = True
                    else:
                        #Input the name again
                        inputtedName = simpledialog.askstring("Please Input", "MUST NOT BE BLANK\nInput Name for new client:")

                #
                # End of validation
                #

                
                name = str(len(clientList)+1) +". " + inputtedName
                url = "client-webpages/" + name[3:len(name)]

                versionInput = simpledialog.askstring("Please Input","Input current software verison for new client -\nCurrent updated version: " + open("data/current-update-version.txt","r").read() + "  -  type this if they have not yet \nrecieved an update prior to being added to the program.")


                #
                # VALIDATE INPUTTED VERSION
                #

                validated = False
                
                while not validated: #keep looping until it is validated
                    if "." in versionInput: #Validate existance of a decimal point (Format check)
                        try: #Do a type check on the input
                            float(versionInput) #Try converting it to a float
                            validated = True #If this passed, it is of type float
                        except:
                            #Ask for input again
                            versionInput = simpledialog.askstring("Please Input","MUST BE A FLOATING POINT NUMBER\nInput current software verison for new client -\nCurrent updated version: " + open("data/current-update-version.txt","r").read() + "  -  type this if they have not yet \nrecieved an update prior to being added to the program.")
                    else:
                        #Ask for input again
                        versionInput = simpledialog.askstring("Please Input","MUST HAVE A DECIMAL PLACE\nInput current software verison for new client -\nCurrent updated version: " + open("data/current-update-version.txt","r").read() + "  -  type this if they have not yet \nrecieved an update prior to being added to the program.")

                #
                # End of validation
                #
                
                version = "v" + versionInput
            else:
                name = n
                url = u
                version = v

            c = client(name, url, version, True)
            clientList.append(c)
            c.drawClient()
            box = tickBox(15,tickbox_Y,True)
            btnList.append(box)
            tickbox_Y += 65
            box.boundClient = clientList.index(c) #Bind this checkbox with this client
            
            #Open the text file storing client data
            clientTXT = open("data/client-list.txt","r+")
            deleteContent(clientTXT)
            #Add to text file
            for i in clientList:
                if clientList.index(i) < len(clientList)-1:
                    clientTXT.write(i.name + "," + i.url + "," + i.version + "," + str(i.active) + "\n")
                else:
                    clientTXT.write(i.name + "," + i.url + "," + i.version + "," + str(i.active))


            clientTXT.close()

            #Add the client webpage using the Data_Management_Module.py i created.
            data_manager.createClientWebpage(c)
            data_manager.writeUpdateInformation(c,c.version)
        else:
            messagebox.showwarning(title="Warning", message="You can have no more than 6 clients.")


    #Function to remove last client from list
    def removeClient():
        global tickbox_Y, btnList
        
        if len(clientList) > 0:
            
            #
            # TYPE CHECK VALIDATION - Must be an int, used when removing a client
            #

            userChoice = simpledialog.askstring("Please Input", "What is the number from the list, of the client you want to remove?")
            validated = False
            
            while not validated: #Run loop until it is validated
                try:
                    userChoice = int(userChoice) #Try making the input an int
                    if userChoice <= len(clientList): #Check if that client is in the list (Range check)
                        validated = True #If this passed, it is validated
                    else:
                        userChoice = simpledialog.askstring("Please Input", "THAT CLIENT IS NOT IN THE LIST\nWhat is the number from the list, of the client you want to remove?")
                except:
                    #It was not an int, get them to input again
                    userChoice = simpledialog.askstring("Please Input", "MUST BE A NUMBER\nWhat is the number from the list, of the client you want to remove?")

            #
            # End of validaton
            #

            
            #Remove the client webpage using the Data_Management_Module.py i created.
            data_manager.removeClientWebpage(clientList[userChoice-1])
            
            clientList[userChoice-1].destroyClient()
            btnList[userChoice-1].remove()
            clientList.pop(userChoice-1)
            btnList.pop(userChoice-1)
            tickbox_Y -= 65


            clientTXT = open("data/client-list.txt","r+")
            lines = clientTXT.readlines()
            deleteContent(clientTXT)
            
            for line in lines:
                if line != "\n":
                    if int(line[0:1]) != userChoice:
                        clientTXT.write(line)
            clientTXT.close()


            clientTXT = open("data/client-list.txt","r+")
            lines = clientTXT.readlines()
            deleteContent(clientTXT)
            for i in range(0,len(lines)):
                if lines[i] != "\n":
                    if i < len(lines)-1:
                        line = str(i+1) + ". " + lines[i][3:len(lines[i])] + "\n"
                    else:
                        line = str(i+1) + ". " + lines[i][3:len(lines[i])]
                    clientTXT.write(line)
            clientTXT.close()

            

            if userChoice <= len(clientList):
                #Re-draw the rest of the list as the user removed something from the middle
                for i in range(0,len(clientList)):
                    clientList[i].destroyClient() #Delete all gui elements
                for i in range(0,len(btnList)): #Delete all check-boxes
                    btnList[i].remove()

                #Reset variables
                tickbox_Y = 65 
                btnList = []

                #Loop through all remaining clients and draw them one by one
                for i in range(0,len(clientList)):
                    clientList[i].name = str(i+1) + ". " + clientList[i].name[3:len(clientList[i].name)] #Have the name with the right number or id out the front
                    clientList[i].drawClient()
                    box = tickBox(15,tickbox_Y,clientList[i].active)
                    btnList.append(box)
                    tickbox_Y += 65
                    box.boundClient = i #Bind this checkbox with this client

        else:
            messagebox.showwarning(title="Warning", message="There is nothing to remove. Please add a client.")
            

    #Add and Remove buttons setup
    addButton = Button(root,command=lambda: addClient(True,"","",""),width=8,height=2, text="Add", bg="#333333",fg="White",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1)
    addButton.place(x=20,y=590)

    removeButton = Button(root,command=removeClient, width=8,height=2, text="Remove", bg="#333333",fg="White",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1)
    removeButton.place(x=130,y=590)

    #Home Button setup
    homeButton = Button(root,width=13,height=2,command=lambda: openHomePage(root), text="Return to Home", bg="#666666",fg="Black",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1)
    homeButton.place(x=534,y=590)



    

    root.mainloop() #Begin main GUI Loop

    # END OF PAGE TWO SETUP #


#-----------------------------------------------------------------------------------------------

#Function accessed by automation module to display a new event
def createEvent(date,clients,email):
    global arrEventPanels, arrDatePanels, clientList, selectedMonth

    arrEventPanels.append([date.day,date.month,email,clients])

    if selectedMonth+1 == date.month:
        if len(clients) == len(clientList):
            arrDatePanels[date.day-1].drawAllClientsEvent()
        else:
            arrDatePanels[date.day-1].drawMultipleClientsEvent(len(clients))

    eventTXT = open("data/scheduled-events.txt","r+")
    deleteContent(eventTXT)
    
    for event in arrEventPanels:
        outputClients = ""
        for c in event[3]:
            if event[3].index(c) < len(event[3]) - 1:
                outputClients = outputClients + c.name[3:len(c.name)] + ","
            else:
                outputClients = outputClients + c.name[3:len(c.name)]
        if arrEventPanels.index(event) < len(arrEventPanels) - 1:
            eventTXT.write(str(event[0]) + "," + str(event[1]) + "," + str(event[2]) + "," + outputClients + "\n")
        else:
            eventTXT.write(str(event[0]) + "," + str(event[1]) + "," + str(event[2]) + "," + outputClients)
    
    eventTXT.close()


#-----------------------------------------------------------------------------------------------

    
def loadClients():
    global clientList
    
    clientTXT = open("data/client-list.txt","r")
    lines = clientTXT.readlines()
    for line in lines:
        if line != "\n":
            data = line.split(",")
            data3 = ""
            if "True" in data[3]:
                 data3 = True
            elif "False" in data[3]:
                data3 = False
            c = client(data[0],data[1],data[2],data3)
            clientList.append(c)


def loadCalendarEvents():
    global arrEventPanels, clientList

    eventTXT = open("data/scheduled-events.txt","r")
    lines = eventTXT.readlines()

    for line in lines:
        if line != "\n":
            data = line.split(",")
            
            #Save the active clients' objects to the update information
            arrEventClients = [] #The array that will be passed into the event of client objects
            for client in clientList: #Loop through all the clients
                for i in range(3, len(data)): #Loop through  clients in txt file
                
                    if client.name[3:len(client.name)] == data[i]:
                        arrEventClients.append(client)

            emailBool = False
            if data[2] == "True":
                emailBool = True
            else:
                emailBool = False
                
            event = automation_module.updateEvent(arrEventClients,datetime(2020, int(data[1]), int(data[0])),emailBool)
            automation_module.arrEvents.append(event)

            #Start a multithreading process on the event loop method in order to run this loop independently of the program
            th = threading.Thread(target=event.runEventLoop)
            th.start()

    eventTXT.close()
    
if isFirstLoad:
    loadClients()
    isFirstLoad = False

#------------------------------------------------------------------------------------------------

    
def Setup_GUI_Page3():
    global dayLabels, clientList, popupMenu, arrDatePanels, eventInformation, activeClients
    
    root = Tk()

    eventInformation = [False, datetime.now(), []] #Array to store the information for a newly added event
    activeClients = []
    
    setupWindow(root) #Draw basic window

    firstPageLoad = True

    #Side panel frame
    sidePanel = Frame(root,width=200,height=390,bg="#666666")
    sidePanel.place(x=10,y=150)
    
    #Configure Static text labels
    title = Label(root, text="Update Scheduler",bg="#333333",fg="White",font=("Helvetica", 18, 'bold'))
    title.place(x=20,y=20)

    subtitle = Label(sidePanel, text="Add Update Event:",bg="#666666",fg="White",font=("Helvetica", 15))
    subtitle.place(x=8,y=5)

    clientLabel = Label(sidePanel, text="Clients:",bg="#666666",font=("Helvetica", 13))
    clientLabel.place(x=8,y=50)

    dateLabel = Label(sidePanel, text="Date:",bg="#666666",font=("Helvetica", 13))
    dateLabel.place(x=8,y=130)

    emailLabel = Label(sidePanel, text="Email Reminders:",bg="#666666",font=("Helvetica", 13))
    emailLabel.place(x=8,y=215)
    
    #Main buttons setup
    homeButton = Button(root,width=13,height=2,command=lambda: openHomePage(root), text="Return to Home", bg="#666666",fg="Black",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1)
    homeButton.place(x=644,y=590)

    clearButton = Button(root,width=16,height=2, text="Clear All Events", bg="#333333",fg="White",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1)
    clearButton.place(x=20,y=590)


    #Dropdown menu setup
    # Create a Tkinter variable
    tkvar = StringVar(root)

    # Array of options 
    choices = ["Select Client(s)"]
    for i in clientList:
        choices.append(i.name[3:len(i.name)])
        
    tkvar.set("Select Client(s)") # set the default option

    popupMenu = OptionMenu(sidePanel,tkvar, *choices)
    popupMenu.config(width=16,bg="#999999",fg="White",highlightthickness=1, highlightbackground="White",relief='flat')
    popupMenu.place(x=8,y=80)

    # on change dropdown value
    def change_dropdown(*args):
        global popupMenu, activeClients, clientList

        #Loop through all choices and place a tick next to the selected client
        for i in range(0,len(choices)):
            if choices[i] == tkvar.get() and choices[i] != "Select Client(s)":
                if choices[i][0:1] != "✅":
                    activeClients.append(choices[i])
                    choices[i] = "✅ " + tkvar.get()
                else:
                    activeClients.pop(activeClients.index(choices[i][2:len(choices[i])]))
                    choices[i] = choices[i][2:len(choices[i])]
                    
            popupMenu.destroy() #Remove drop down menu
            popupMenu = OptionMenu(sidePanel, tkvar, *choices) #Replace with new one
            popupMenu.config(width=16,bg="#999999",fg="White",highlightthickness=1, highlightbackground="White",relief='flat')
            popupMenu.place(x=8,y=80)

        #Save the active clients' objects to the update information
        arrEventClients = [] #The array that will be passed into the event of client objects
        for client in clientList: #Loop through all the clients
            for activeClient in activeClients: #Loop through chosen clients
                if client.name[3:len(client.name)] == activeClient:
                    arrEventClients.append(client)
                    
        eventInformation[2] = arrEventClients #Store it to the event information

        #Generate the new 'title' for the drop down menu based on the chosen clients
        outputString = ""
        exceeded = False
        for i in range(0,len(activeClients)):
            if len(outputString) < 17:
                if i < len(activeClients)-1:
                    outputString = outputString + activeClients[i] + ","
                else:
                    outputString = outputString + activeClients[i]
            else:
                exceeded = True
        if exceeded:
            outputString = outputString + "..."

        if len(outputString) != 0:
            tkvar.set(outputString)
        else:
            tkvar.set("Select Client(s)")

    # link function to change dropdown
    tkvar.trace('w', change_dropdown)




    #Date Entry Field
    import sys
    sys.path.append(os.getcwd() + "/libraries/") #Change working directory to import modules
    
    from tkcalendar import dateentry #Import installed modules stored in libraries folder
    
    sys.path.append(os.getcwd()[0:len(os.getcwd())-11])
    
    #Event called when a new date is picked
    def dateSelected(event):
        selectedDate = datePicker.get_date()
        eventInformation[1] = selectedDate #Load in the selected date to the event information

    datePicker = dateentry.DateEntry(sidePanel,width=20,bg="#999999",fg="white",year=2020) #Create date picker widget
    datePicker.place(x=10,y=157)
    datePicker.bind("<<DateEntrySelected>>",dateSelected)



    #Email reminders toggle switch
    img = PhotoImage(file="images/toggle_switch_off.png")

    def emailToggle():
        global emailReminders
        
        if not emailReminders:
            img.config(file="images/toggle_switch_on.png")
            emailReminders = True
            eventInformation[0] = True

            #if it is the first time, have the user enter their email
            if automation_module.userEmail == "":
                
                #
                # VALIDATE EMAIL ENTRY - Consistency check
                #

                #Get user to input email, then get them to confirm email
                email = simpledialog.askstring("Please Input", "Please input your email:            ")
                emailConfirm = simpledialog.askstring("Please Input", "Please confirm your email:            ")

                #Keep looping if the entered email does not equal the confirmed email
                while email != emailConfirm:
                    #Get them to enter again, telling them the emails do not match, keep doing this until they match
                    email = simpledialog.askstring("Please Input", "Emails do not match! Please input your email:")
                    emailConfirm = simpledialog.askstring("Please Input", "Please confirm your email:            ")

                automation_module.userEmail = email #Save it in the automation module

                #
                # END OF VALIDATION
                #
                
                emailTXT = open("data/user-email.txt","r+")
                deleteContent(emailTXT)
                emailTXT.write(email)
                emailTXT.close()
                
                messagebox.showinfo(title="Success", message="Email added. Reminders are sent a day before the update.\nMake sure to check junk folder if you do not recieve any emails")
        else:
            img.config(file="images/toggle_switch_off.png")
            emailReminders = False
            eventInformation[0] = False

    switch = Button(root, image=img,highlightthickness=1, relief='ridge', command=emailToggle)
    switch.place(x=20,y=410)


    #Function called when an event is submitted. Creates an event class in the automatic updates moudule
    def submitEvent():
        global eventInformation


        #
        # VALIDATE UPDATE SHCEDULER EVENT INFORMATION - This is called when you press the submit button
        #
        
        #Validate they have entered the data correctly before submitting
        if len(eventInformation[2]) > 0: #Validate if they have selected any clients (existence check)
            
            #Validate whether date is in the future or not
            if eventInformation[1].day >= datetime.now().day and eventInformation[1].month >= datetime.now().month and eventInformation[1].year == datetime.now().year:

                if not checkExistingEvents(eventInformation[1]): #Check an event on this date doesnt already exist
                    #The information is valid, make the event object
                    event = automation_module.updateEvent(eventInformation[2],eventInformation[1],eventInformation[0]) #Create the event
                    automation_module.arrEvents.append(event) #Append to array of events

                    #Start a multithreading process on the event loop method in order to run this loop independently of the program
                    th = threading.Thread(target=event.runEventLoop)
                    th.start()

                    messagebox.showinfo(title="Success", message="Event Created.")
                else:
                    #Show warning as two events cannot have same date
                    messagebox.showwarning(title="Warning", message="You cannot have two events on the same date.")
            else:
                #Show warning as selected date is in the past
               messagebox.showwarning(title="Warning", message="The date selected can not be in the past or can not be today.\nIt also must be within this year")
        else:
            #Show warning as no clients were selected
            messagebox.showwarning(title="Warning", message="No selected clients. Please choose some clients for this event.")

        #
        # END OF VALIDATION
        #

        
    submitButton = Button(root,text="Submit",width=9,bg="#999999",font=("Helvetica", 12),highlightbackground="#666666", relief='ridge',highlightcolor="#666666", highlightthickness=1,command=submitEvent)
    submitButton.place(x=18,y=490)

    #--------------------------------------------------------------------------------------------------

    #CALENDAR SETUP

    global arrEventPanels

    #Date panel object for each square on the calendar
    class datePanel():
        def __init__(self,X,Y):
            self.frame = Frame(root,bg="#333333",width=83,height=72,highlightthickness=1,highlightbackground="#999999")
            self.frame.place(x=X,y=Y)
            self.mainText = tk.StringVar()
            self.mainText.set("")
            self.txt = Label(self.frame, textvariable=self.mainText, bg="#333333", fg="#999999",font=("Helvetica",12))
            self.txt.place(x=4,y=4)
            self.updateLabel = Label(self.frame)
            self.buttonImg = PhotoImage(file = "images/calendar_cross_button.png")
            self.crossButton = Button(self.frame)

        def drawAllClientsEvent(self):
            self.frame.config(highlightbackground="red",highlightthickness=2)
            self.updateLabel = Label(self.frame, text="Update:\nAll Clients",bg="#333333", fg="red")
            self.updateLabel.place(x=10,y=22)
            
            self.crossButton = Button(self.frame, image=self.buttonImg, bd=0,highlightthickness=0,command=self.resetFrame)
            self.crossButton.place(x=55,y=0)

        def drawMultipleClientsEvent(self, clientsAmout):
            self.frame.config(highlightbackground="#03c2fc",highlightthickness=2)
            self.updateLabel = Label(self.frame, text="Update:\n"+str(clientsAmout)+" Client(s)",bg="#333333", fg="#03c2fc")
            self.updateLabel.place(x=10,y=22)

            self.crossButton = Button(self.frame, image=self.buttonImg, bd=0,highlightthickness=0,command=self.resetFrame)
            self.crossButton.place(x=55,y=0)

        def hideEvent(self):
            self.frame.config(highlightbackground="#999999",highlightthickness=1)
            self.updateLabel.config(text="")
            self.crossButton.place_forget()
            
        def resetFrame(self):
            global arrEventPanels

            #Remove from global event array
            day = self.mainText.get()
            for event in arrEventPanels:
                if int(day) == event[0]:
                    arrEventPanels.pop(arrEventPanels.index(event))

            #Re-write the text file
            eventTXT = open("data/scheduled-events.txt","r+")
            deleteContent(eventTXT)

            for event in arrEventPanels:
                outputClients = ""
                for c in event[3]:
                    if event[3].index(c) < len(event[3]) - 1:
                        outputClients = outputClients + c.name[3:len(c.name)] + ","
                    else:
                        outputClients = outputClients + c.name[3:len(c.name)]
                if arrEventPanels.index(event) < len(arrEventPanels) - 1:
                    eventTXT.write(str(event[0]) + "," + str(event[1]) + "," + str(event[2]) + "," + outputClients + "\n")
                else:
                    eventTXT.write(str(event[0]) + "," + str(event[1]) + "," + str(event[2]) + "," + outputClients)
    
            eventTXT.close()

            messagebox.showinfo(title="Event Deleted", message="Event has been deleted succesfully and will no longer be ran")
            
            self.frame.config(highlightbackground="#999999",highlightthickness=1)
            self.updateLabel.config(text="")
            self.crossButton.destroy()


    posX = 208
    posY = 180

    #Reset values when page is first loaded
    if firstPageLoad:
        dayLabels = []
        arrDatePanels = []
        firstPageLoad = False

    #Draw and create object for each panel on the calendar
    for i in range(0,5):
        for j in range(0,7):
            panel = datePanel(posX,posY) #Create the object
            arrDatePanels.append(panel) #Add to array of panels
            posX+=83
        posY+=72
        posX=208

    #Main function to draw calendar given a month
    def drawCalendar(currentMonth):
        global arrDatePanels, dayLabels


        #An example of an event and how it would function, uncomment to test
        #arrDatePanels[3].drawAllClientsEvent()
        #arrDatePanels[15].drawMultipleClientsEvent(3)
        

        X = 208

        #Add in day numbers
        months = [31,28,31,30,31,30,31,31,30,31,30,31]
        
        for panel in arrDatePanels:
            panel.mainText.set("")
            
        for i in range(0,months[currentMonth]):
            arrDatePanels[i].mainText.set(str(i+1))

        
        
        #Add day labels dependent on which month it is.
        startingDays = [3,6,0,3,5,1,3,6,2,4,0,2]
        days = ["SUN","MON","TUE","WED","THU","FRI","SAT"]
        reshuffledDays = []

        #Create a properly ordered days array
        for i in range(startingDays[currentMonth], len(days)):
            reshuffledDays.append(days[i])

        for i in range(0, startingDays[currentMonth]):
            reshuffledDays.append(days[i])

        #Create Days of week labels
        if len(dayLabels) == 0:
            firstTime = True
        else:
            firstTime = False
            
        for i in range(0,7):
            if firstTime:
                day = Frame(root,width=83,height=30,highlightthickness=1,highlightbackground="#999999",bg="#333333")
                day.place(x=X,y=150)
                X+=83
                varText = tk.StringVar()
                varText.set(reshuffledDays[i])
                txt = Label(day,textvariable=varText,fg="#999999",bg="#333333")
                txt.place(x=25,y=3)
                dayLabels.append([txt,varText])
            else:
                dayLabels[i][1].set(reshuffledDays[i])

                
    drawCalendar(selectedMonth) #Set july (current month) as deafult month

    allMonths = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"]
    monthLabel = Label(root, text=allMonths[selectedMonth],fg="White",bg="#333333",font=("Helvetica",15))
    monthLabel.place(x=247,y=110)


    def drawEvents():
        global arrDatePanels, arrEventPanels, selectedMonth, clientList

        for event in arrEventPanels:
            if selectedMonth+1 == event[1]:
                if len(event[3]) == len(clientList):
                    arrDatePanels[event[0]-1].drawAllClientsEvent()
                else:
                    print(event[3])
                    print(len(event[3]))
                    arrDatePanels[event[0]-1].drawMultipleClientsEvent(len(event[3]))

    def hideEvents():
        global arrDatePanels, arrEventPanels
        for event in arrEventPanels:
            arrDatePanels[event[0]-1].hideEvent()

    if len(arrEventPanels) > 0:
        hideEvents()
        drawEvents()
        
            
    #Buttons to scroll the months left and right
    def scrollRight(btn):
        global selectedMonth
        selectedMonth += 1
            
        if selectedMonth == 12:
            selectedMonth = 0
        
        drawCalendar(selectedMonth)
        btn.config(text=allMonths[selectedMonth])

        hideEvents()
        drawEvents()

    def scrollLeft(btn):
        global selectedMonth
        selectedMonth -= 1
        
        if selectedMonth == -1:
            selectedMonth = 11

        drawCalendar(selectedMonth)
        btn.config(text=allMonths[selectedMonth])

        hideEvents()
        drawEvents()

    #Draw GUI for these buttons
    i = PhotoImage(file="images/date_arrow_right.png")
    rightButton = Button(root,image=i,bd=0,highlightthickness=0, command=lambda: scrollRight(monthLabel))
    rightButton.place(x=300,y=110)

    i2 = PhotoImage(file="images/date_arrow_left.png")
    leftButton = Button(root,image=i2,bd=0,highlightthickness=0, command=lambda: scrollLeft(monthLabel))
    leftButton.place(x=216,y=110)

    loadCalendarEvents()
    
    #--------------------------------------------------------------------------------------------------

    root.mainloop() #Begin main GUI Loop

    # END OF PAGE THREE SETUP #

#-------------------------------------------------------------------------------------------------------

    
def initialise():
    Setup_GUI_Page1()






